* 动态规划
** 总体思想
   由已知的，推导出未知的，从而避免从头遍历。
** 背包问题
*** 01背包
**** 问题描述
     原版：
有一个背包，可容纳重量为W的物品。有i个物品（每个物品只有一个），第j个物品的重量为W[j]，价值为V[j]。求背包可容纳物品的最大价值。
     改版：
你有n项作业，你只有k的时间，每一项作业需a个小时完成。但是，因为作业的内容、难度不同，对于每一项作业老师取得的快乐值也不同。
比如：如果你完成了一道全班只有你才完成的数学难题，老师会很高兴，即使你没有把定义练习抄写1000000000遍，老师也不会批评你；然而，如果你只把1+1=2这类的题做完了，
而稍微难一点儿的题就不做，老师就会很生气，认为你很懒，而让你把定义再抄100000000000遍。问，在有限的时间内，如何使老师获得的快乐值最大（从而免去抄写）？
**** dp状态
     dp[i][j]表示可以选择前i件物品，背包容量为j时，最大的能装的价值。
***** 状态转移方程
      dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])
对于dp[i][j]，只可能有两种可能：一，选择这件物品；二，不选择这件物品。
因为已经知道了如果选择这件物品，减掉这件物品所占有的重量所能取得的最大价值（因为物品只有一件），也就是dp[i-1][j-w[i]]，再加上第i件物品的价值v[i]，
就是选择第i件物品所能取得的最大价值。
否则，即为不选择第i件物品，最大价值为dp[i-1][j]。
二者中较大的那一个，即为dp[i][j]的值。
**** 例题
***** 输入格式
      第一行为一个数字c，表示共有c组输入
      每组输入的第一行为两个数字，N和W，分别表示有N件物品，背包容量为W。
      接下来共N行，每行两个数字，v和w，分别表示第i件物品的价值和重量
***** 输出格式
      共一行，一个数字，即背包能装的最大价值。
***** 标程
#+begin_src C++
#include<cstdio>
#include<cstring>
#include<algorithm>
#define maxe 10000
using namespace std;
int dp[maxe][maxe],c,N,W,v[maxe],w[maxe];
int main(){
    scanf("%d",&c);
    while(c--){
        scanf("%d%d",&N,&W);
        for(int i = 1;i <= N;i++)
            scanf("%d%d",&v[i],&w[i]);
        for(int i = 1;i <= N;i++)
            for(int j = w[i];j <= W;j++)
                dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]);
        printf("%d\n",dp[N][W]);
    }
}
#+end_src
***** 样例数据
****** 输入
       1
       5 8
       2 1
       5 5
       6 2
       8 4
       1 7
****** 输出 
       16
****** dp表
|   | 0 | 1 | 2 | 3 | 4 |  5 |  6 |  7 |  8 | i
| 0 | 0 | 0 | 0 | 0 | 0 |  0 |  0 |  0 |  0 |
| 1 | 0 | 2 | 2 | 2 | 2 |  2 |  2 |  2 |  2 |
| 2 | 0 | 2 | 2 | 2 | 2 |  5 |  5 |  5 |  5 |
| 3 | 0 | 2 | 6 | 8 | 8 |  8 |  8 | 11 | 11 |
| 4 | 0 | 2 | 6 | 8 | 8 | 10 | 14 | 16 | 16 |
| 5 | 0 | 2 | 6 | 8 | 8 | 10 | 14 | 16 | 16 |
 j
**** 化简为一维数组
***** 原理
      dp表更新后，有许多都为中间变量，无用。可降维，注意要改为从后往前遍历。
***** 标程
#+begin_src C++
#include<cstdio>
#include<algorithm>
#define maxe 10000
using namespace std;
int dp[maxe],c,N,W,v[maxe],w[maxe];
int main(){
    scanf("%d",&c);
    while(c--){
        for(int i = 1;i <= N;i++)
            scanf("%d%d",&v[i],&w[i]);
        for(int i = 1;i <= N;i++)
            for(int j = W;j >= w[i];j--)
                dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
        printf("%d",dp[W]);
    }
    return 0;
}
#+end_src
***** 样例数据
****** 输入
       1
       5 8
       2 1
       5 5
       6 2
       8 4
       1 7
****** 输出 
       16
****** dp过程
1.初始化
    | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
2.第一次填充
    | 0 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
3.开始第二行的填充
                                      j
    | 0 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 5 |
                                  j
    | 0 | 2 | 2 | 2 | 2 | 2 | 2 | 5 | 5 |
………… ………… …………
    | 0 | 2 | 2 | 2 | 2 | 5 | 5 | 5 | 5 |    ————————本轮查找完毕
4.开始第三行的填充
                                       j
    | 0 | 2 | 2 | 2 | 2 | 5 | 5 | 5 | 11 |
                                   j
    | 0 | 2 | 2 | 2 | 2 | 5 | 5 | 11 | 11 |
………… ………… …………
………… ………… …………
直至最后
    | 0 | 2 | 6 | 8 | 8 | 10 | 14 | 16 | 16 |
*** 完全背包
**** 问题描述
    你是一名小偷，半夜，你偷偷溜进了城市的地下金库，成山一堆的金子摆在你的面前。
    你身上只有一个背包，能装的重量有限。可是，金子有很多种类，例如：纯金的金条，
    24K金的首饰，16K金的金锭…………每种金子的重量和价钱各不相同。因为你好不容易
    冒着生命危险进来一次，所以你想拿走最多的钱，但是，你只能在里面停留限定的时间，
    否则，保安就会发现并逮捕你。求你最多能拿走多少钱？
**** dp状态
     dp[i][j]表示可以选择前i件物品，背包容量为j时，最大的能装的价值。
***** 状态转移方程
      dp[i][j]=max(dp[i-1][j],dp[i][j-w[i]]+v[i])
对于dp[i][j]，只可能有两种可能：一，再次选择这件物品；二，不选择这件物品。
因为已经知道了如果再次选择这件物品，减掉这件物品所占有的重量所能取得的最大价值，也就是dp[i][j-w[i]]（因为物品有无数件），再加上第i件物品的价值v[i]，
就是选择第i件物品所能取得的最大价值。
否则，即为不选择第i件物品，最大价值为dp[i-1][j]。
二者中较大的那一个，即为dp[i][j]的值。
**** 例题
***** 输入格式
      第一行为一个数字c，表示共有c组输入
      每组输入的第一行为两个数字，N和W，分别表示有N种物品，背包容量为W。
      接下来共N行，每行两个数字，v和w，分别表示第i种物品的价值和重量
***** 输出格式
      共一行，一个数字，即背包能装的最大价值。
***** 标程
#+begin_src C++
#include<cstdio>
#include<cstring>
#include<algorithm>
#define maxe 10000
using namespace std;
int dp[maxe][maxe],c,N,W,v[maxe],w[maxe];
int main(){
    scanf("%d",&c);
    while(c--){
        scanf("%d%d",&N,&W);
        for(int i = 1;i <= N;i++)
            scanf("%d%d",&v[i],&w[i]);
        for(int i = 1;i <= N;i++)
            for(int j = w[i];j <= W;j++)
                dp[i][j]=max(dp[i-1][j],dp[i][j-w[i]]+v[i]);
                //与01背包唯一不同的地方（dp[i][j]=max(dp[i-1][j],dp[i][j-w[i]]+v[i])而不是dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])
        printf("%d\n",dp[N][W]);
    }
}
#+end_src
***** 样例数据
****** 输入
       1
       5 8
       2 1
       5 5
       6 2
       8 4
       1 7
****** 输出 
       24K
****** dp表
|   | 0 | 1 | 2 | 3 |  4 |  5 |  6 |  7 |  8 |   i
| 0 | 0 | 0 | 0 | 0 |  0 |  0 |  0 |  0 |  0 |
| 1 | 0 | 2 | 4 | 6 |  8 | 10 | 12 | 14 | 16 |
| 2 | 0 | 2 | 4 | 6 |  8 | 10 | 12 | 14 | 16 |
| 3 | 0 | 2 | 6 | 8 | 12 | 14 | 18 | 20 | 24 |
| 4 | 0 | 2 | 6 | 8 | 12 | 14 | 18 | 20 | 24 |
| 5 | 0 | 2 | 6 | 8 | 12 | 14 | 18 | 20 | 24 |
 j
**** 化简为一维数组
***** 原理
      dp表更新后，有许多都为中间变量，无用。可降维，注意这里不同与01背包，不改变遍历顺序，依旧是从头向后依次遍历。
***** 标程
#+begin_src C++
#include<cstdio>
#include<algorithm>
#define maxe 10000
using namespace std;
int dp[maxe],c,N,W,v[maxe],w[maxe];
int main(){
    scanf("%d",&c);
    while(c--){
        for(int i = 1;i <= N;i++)
            scanf("%d%d",&v[i],&w[i]);
        for(int i = 1;i <= N;i++)
            for(int j = w[i];j <= W;j++)//与01背包唯一不同的地方是此处
                dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
        printf("%d",dp[W]);
    }
    return 0;
}
#+end_src
***** 样例数据
****** 输入
       1
       5 8
       2 1
       5 5
       6 2
       8 4
       1 7
****** 输出 
       24
*** 多重背包
**** 问题描述
     熊孩子，你好！现在，摆在你面前的有n种类型的糖果，第i种类型的糖果有a[i]个，每种类型的糖果重量和美味度也各不相同。
     现在，你有一个容量为W的袋子，老师即将到达战场。问，最多能够拿走美味度总和为多少。
**** 思路
***** 转化为01背包问题求解
很简单，把每个物品拆开来看，逐一dp。
#+begin_src C++
if(v >= k * c[i]) F[i][v] = max(F[i][v], F[i-1][v-k*c[i]] + k * w[i]);//v表示dp表中的j，i表示i，k表示第i件物品取几个。
#+end_src
***** 二进制优化
任何一个数都可以表示为2^n的和。
|  1 | = |     1 |
|  2 | = |     2 |
|  3 | = |   1+2 |
|  4 | = |     4 |
|  5 | = |   1+4 |
|  6 | = |   2+4 |
|  7 | = | 1+2+4 |
|  8 | = |     8 |
|  9 | = |   8+1 |
| 10 | = |   8+2 |
因为dp求的总是最优解，所以对每个分成log len堆，分别遍历，他们的相加之和便是取的个数。
#+begin_src C++
dp[k]=max(dp[k],dp[k-a[i]*j]+a[i]*j);//k表示分堆的数值，i、j表示为dp[i][j]，j为第几堆。
#+end_src
**** 例题
https://www.luogu.org/problem/P1776  洛谷的P1776
**** 标程
二进制优化
#+begin_src C++
#include<cstdio>
#include<algorithm>
#define maxe 10000000
using namespace std;
int len,W,wi[maxe],vi[maxe],sum[maxe];//len记录物品种类数量，W记录背包容量，wi为物品重量，vi为物品价值，sum为物品个数。
int dp[maxe];
int main(){
    scanf("%d%d",&len,&W);
    for (int i = 1; i <= len; i++)
    {
        scanf("%d%d%d",&vi[i],&wi[i],&sum[i]);
    }
    for (int i = 1; i <= len; i++)
    {
        int max_num=min(sum[i],W/wi[i]);//第i种物品最多能选几件。
        for (int n = 1; max_num > 0; n*=2)
        {
            if(n > max_num)n=max_num;//如果大于num，遍历剩余的。
            max_num-=n;//减去已经遍历过的
            for (int j = W; j >= wi[i]*n; j--)
            {
                dp[j]=max(dp[j],dp[j-wi[i]*n]+vi[i]*n);//正常进行dp
            }
        }
    }
    printf("%d\n",dp[W]);
    return 0;
}
#+end_src
** 最长公共子序列(LCS)
*** 问题描述
    给定两个字符串，求出他们共同拥有的最长子串长度。注意：子串并不一定要连接在一起。
**** 例子
     串1：
| f | r | a | m | e |   |
     串2：
| f | a | m | i | l | y |
     最长公共子序列为：
| f | a | m |
*** dp状态
    dp[i][j]表示在串1前i位和串2前2位的最长公共子序列。
**** 状态转移方程
     当a[i]==b[j]时，dp[i][j]=dp[i-1][j-1]+1
     当a[i]!=b[j]时，dp[i][j]=max(dp[i-1][j],dp[i][j-1])
*** 例题
**** 输入格式
     共两行，第一行为字符串a；第二行为字符串b。
**** 输出格式
     一个数字，即a与b的最长公共子序列长度。
**** 输入
   frame
   family
**** 输出
     3
**** 标程
#+begin_src C++
#include<cstdio>
#include<cstring>
#include<algorithm>
#define maxe 2000
using namespace std;
char a[maxe],b[maxe];
int lena,lenb;
int dp[maxe][maxe];
int main(){
    while (~scanf("%s%s",a,b))
    {
        memset(dp,0,sizeof(dp));
        lena=strlen(a);
        lenb=strlen(b);
        for (int i = 1; i <= lena; i++)
        {
            for (int j = 1; j <= lenb; j++)
            {
                if (a[i-1]==b[j-1])
                {
                    dp[i][j]=dp[i-1][j-1]+1;
                }
                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }
        }
        printf("%d\n",dp[lena][lenb]);
    }
    return 0;
}
#+end_src
** 最长上升子序列(LIS)
** 区间dp
** 数位dp
** KMP算法
*** 定义
   有一个主串和一个模式串，求模式串在主串中出现的所有位置，没有则返回-1。
*** 例子
   | a | b | c | a | b | ------- 主串
   | a | b | c |   |   | ------- 模式串
   共出现1次，为0位。
*** 流程
**** 建立next数组
**** 定义 
     用next[i]=j表示当在第i位失配时，从模式串的第j位继续匹配。
**** 方法
     动态规划！！！
 
   [[./Images/KMP.png]]
    上图为例：
    求next[j+1]时，已经知道next[0]~next[j]的值
1.k==j?next[j+1]=next[j]+1:第二步
2.j==h?next[j+1]=next[k]+1:第三步
………………………………
        原理：
    由next数组的定义可知A1==A2，如果k==j，开始匹配就应在k的下一位。
    又因为A1==A2，所以b1==b2，b2==b3，也就是b1==b2==b3。
    又因为b1==b2==b3，所以c1==c2==c3==c4。p
**** 代码
#+begin_src c++
void getnext (char P[],int f[]){//P为模式串，f为next数组。
  	int m=strlen(P);//取得模式串长度。
	  f[0]=f[1]=0;//前两位一定是0，为以后填充初始化。
	  for (int i=1;i<m;i++){//获取next数组每一位，要求第i+1位。
    		int j=f[i];//记录上图j的位置。
		    while (j&&P[i]!=P[j]) j=f[j];//如果j和k位相等，则跳出循环；否则，把索引调整至h的位置。重复此过程，直至出现相等或索引指向0。
		    f[i+1]=P[i]==P[j]?j+1:0;//判断i和j位是否相等，避免不相等却+1情况。
}
#+end_src
**** 开始匹配
***** 方法
     一位一位向前匹配，如果失配，则模式串索引跳转到失配位next数组的指向。
     |---+---+---+---+---+---+---|
     | i |   |   |   |   |   |   |
     | a | b | c | d | a | b | c |
     |---+---+---+---+---+---+---|
     | a | b | c |   |   |   |   |
     | j |   |   |   |   |   |   |
     |---+---+---+---+---+---+---|
     因为i不回退，只有j回退，所以提高了算法的效率。
***** 标程
#+begin_src C++
#include <cstdio>
#include <cstring>
using namespace std;
const int maxn = 1100000;
char s1[maxn],s2[maxn];
int next[maxn];
void getnext (char P[],int f[]){
	int m=strlen(P);
	f[0]=f[1]=0;
	for (int i=1;i<m;i++){
		int j=f[i];
		while (j&&P[i]!=P[j]) j=f[j];
		f[i+1]=P[i]==P[j]?j+1:0;
	}
}
int find(char T[],char P[],int f[]) {
	int n=strlen(T);
	int m=strlen(P);
	int ans = 0;
	getnext(P,f);
	int j=0;
	for (int i=0;i<n;i++){
		while (j&&P[j]!=T[i]) j=f[j];
		if (P[j]==T[i]) j++;
		if (j==m){ 
			ans++;
			printf("%d\n",i-j+2);
		}
	}
	return ans;
}
int main (){
	scanf("%s%s",s1,s2);//s1为主串，s2为模式串。
	find(s1,s2,next);
	int lens2 = strlen(s2);
	for (int i = 1 ;i<= lens2 ;i++)
		printf("%d ",next[i]);
	printf("\n");
	return 0;
}
#+end_src
* 其他
** 进制问题
*** 非十进制转换为十进制
实数为整数部分加小数部分。
**** 整数部分
例：
    八进制数12359转换为十进制
    [[./Images/进制转换1.png]]
    结果为5316
**** 小数部分
例：
    0.1010B转换为十进制
    [[./Images/小数进制转换1.png]]
    结果为0.65625J
*** 十进制转换为非十进制
实数为整数部分加小数部分。
**** 整数部分
     短除法：
例：
    把十进制数13546化为二进制
    [[./Images/进制转换2.png]]
    因此，结果为11010011101010（从底向上）。
**** 小数部分
例：
    把0.659J转换为二进制
    0.659 × 2 ………… 1（整数部分）
    ——————————
    0.318 × 2 ………… 0
    ——————————
    0.636 × 2 ………… 1
    ——————————
    0.272 × 2 ………… 0
    ——————————
    0.544 × 2 ………… 1
    ——————————
    0.88 × 2 ………… 0
    ——————————
    0.176 × 2 ………… 0
    ——————————
    0.352 × 2 ………… 0
    ——————————
    0.704 × 2 ………… 1
    ——————————
    0.408 × 2 ………… 0
    ——————————
    0.816 × 2 ………… 1
    ………………………………………………………………………………………………
其结果为0.1010011001100110011001100110011001100110011001100111B
** 邻接矩阵与邻接表
*** 邻接矩阵
**** 使用情况
     边比较集中
**** 方式
     先用结构体定义next_node
#+begin_src C++
struct next_node{
    int next_id,value;
};
#+end_src
     使用edge[maxe][maxe]二维数组来存储,edge[i][j]表示从编号为i的结点到编号为edge[i][j].next_id的结点的权重为edge[i][j].value。
**** 例子
      [[./Images/邻接矩阵与邻接表.svg]]
     |   |   1 |   2 |   3 |   4 |   5 |   6 |
     | 1 |   0 |   5 |   2 |   6 | INF | INF |
     | 2 |   5 |   0 | INF | INF |   1 |   5 |
     | 3 |   2 | INF |   0 | INF | INF |   3 |
     | 4 |   6 | INF | INF |   0 |   4 | INF |
     | 5 | INF |   1 | INF |   4 |   0 |   2 |
     | 6 | INF |   5 |   3 | INF |   2 |   0 |
     |   |     |     |     |     |     |     |
*** 邻接表
**** 使用情况
     边比较分散
**** 方式
     用vector类型的不定数组edge[maxe]来存储，edge[i][j]表示从编号为i的结点到编号为j的结点的权重为edge[i][j]。
**** 例子
     [[./Images/邻接矩阵与邻接表.svg]]
     | 1 | -> | 2,5 | 3,2 | 4,6 |
     | 2 | -> | 1,5 | 5,1 | 6,5 |
     | 3 | -> | 1,2 | 6,3 |     |
     | 4 | -> | 1,6 | 5,4 |     |
     | 5 | -> | 2,1 | 4,4 | 5,2 |
     | 6 | -> | 2,5 | 5,2 | 3,3 |
** 前向星与链式前向星
*** 前向星
**** 使用情况
可优化为链式前向星
**** 方式
     1. 将所有边按照起始结点编号排序
     2. 用head数组记录每个结点编号的第一次出现位置
**** 例子
[[./Images/邻接矩阵与邻接表.svg]]

排序后：
| start | end | weight |
|     1 |   2 |      5 |
|     1 |   3 |      2 |
|     1 |   4 |      6 |
|     2 |   1 |      5 |
|     2 |   5 |      1 |
|     2 |   6 |      5 |
|     3 |   1 |      2 |
|     3 |   6 |      3 |
|     4 |   1 |      6 |
|     4 |   5 |      4 |
|     5 |   2 |      1 |
|     5 |   4 |      4 |
|     6 |   2 |      5 |
|     6 |   3 |      5 |
|     6 |   5 |      2 |

head数组：
| 1 | 2 | 3 | 4 |  5 |  6 |
|---+---+---+---+----+----|
| 1 | 4 | 7 | 9 | 11 | 13 |
*** 链式前向星

** 按位与、按位或、按位异或
*** 按位或(|)
只要有其中一个为1，整体为1；否则为0。
a = 24J = 11000B
b = 18J = 10010B

| 1 | 1 | 0 | 0 | 0 |  === a
| 1 | 0 | 0 | 1 | 0 |  === b
|---+---+---+---+---|
| 1 | 1 | 0 | 1 | 0 |  === c

c = 11010B = 26J
当a的二进制长度不等于b的二进制长度时，缺的用0补齐。
*** 按位与(&)
全部为1，整体为1；否则为0。
a = 24J = 11000B
b = 18J = 10010B

| 1 | 1 | 0 | 0 | 0 |  === a
| 1 | 0 | 0 | 1 | 0 |  === b
|---+---+---+---+---|
| 1 | 0 | 0 | 0 | 0 |  === c

c = 10000B = 16J
当a的二进制长度不等于b的二进制长度时，缺的用0补齐。
*** 按位异或(^)
相同为0，不同为1。
a = 24J = 11000B
b = 18J = 10010B

| 1 | 1 | 0 | 0 | 0 |  === a
| 1 | 0 | 0 | 1 | 0 |  === b
|---+---+---+---+---|
| 0 | 1 | 0 | 1 | 0 |  === c

c = 01010B = 10J
当a的二进制长度不等于b的二进制长度时，缺的用0补齐。
** 原码、反码、补码
   数字在计算机中用二进制（0和1）表示，并用最高位存储符号（正数为0，负数为1）。
例如：
    |3|的二进制表示为0000011。
    则+3表示为00000011，-3表示为10000011。
*** 原码
**** 定义
     符号位加上真值的绝对值。即用第一位表示符号，其余位表示值。（与正常的机器编码相同）
**** 例子
     +3==00000011，-3==10000011。
**** 8位二进制表示的范围
     -127~127
*** 反码
**** 定义
     整数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。
**** 例子
     |----+----------+----------|
     |    |     原码 |     反码 |
     | +1 | 00000001 | 00000001 |
     | -1 | 10000001 | 11111110 |
     |----+----------+----------|
**** 8位二进制表示的范围
     -127～127
*** 补码
**** 定义
     正数的补码是其本身，负数的补码是在其原码基础上，符号位不变，其余各位取反，最后加1(也就是在反码的基础上加1)。
**** 例子
     |----+----------+----------+----------|
     |    |     原码 |     反码 |     补码 |
     | +1 | 00000001 | 00000001 | 00000001 |
     | -1 | 10000001 | 11111110 | 11111111 |
     |----+----------+----------+----------|

**** 8位二进制表示的范围
     -128~1
** 二叉树
*** 形状
**** 完全二叉树
     [[./Images/完全二叉树.svg]]
定义：
    若设二叉树的深度为h，除第h层外，其它各层（1～h-1）的结点数都达到最大个数，第h层所有的结点都连续集中在最左边。
**** 满二叉树
     [[./Images/满二叉树.svg]]
     一棵满二叉树一定是完全二叉树。
定义：
    除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。
*** 结点
**** 根节点（父节点）
     有子节点（出度>0）
**** 叶子节点
     没有子节点（出度==0）
    [[./Images/前中后序遍历.svg]]
**** 前序遍历
顺序：根——左——右
abdhjielcfgk
**** 中序遍历
顺序：左——根——右
hjdibelafckg
**** 后序遍历
顺序：左——右——根
jhidlebfkgca
** 表达式
*** 前缀
**** 定义
     操作符在操作数前面。
**** 例子
     * + a b c * d
*** 中缀
**** 定义
     操作符在操作数之间，也就是人类习惯使用的表达式。
**** 例子
     a * ( b + c ) * d
*** 后缀
**** 定义
     操作符在操作数后面。
**** 例子
     a b c + * d *
** 储存单位
*** 单位转换
    [[./Images/单位转换.svg]]
*** 位图图像
    图像大小为像素块×颜色深度（n位图）个bit。
** 图
*** 环
    [[./Images/环.svg]]
*** 重边（平行边）
    在无向图中，关联一对顶点的无向边如果多于1条，则称这些边为重边，重边的条数称为重数。
    [[./Images/重边.svg]]
*** 无向图
    [[./Images/无向图.svg]]
*** 有向图
     [[./Images/有向图.svg]]
*** 简单图
    无环，无重边。
    [[./Images/简单图.svg]]
*** 完全图
**** 定义
     完全图是一个简单的无向图，且其中每对不同的顶点之间都恰连有一条边相连。
**** 性质
     n个端点的完全图有n个端点以及n(n − 1) / 2条边。
**** [[./Images/完全图.svg]]
*** 正则图
    正则图是指各顶点的度均相同的无向简单图。
    [[./Images/正则图.svg]]
*** 连通图
    任意两个结点之间有直接或间接的连接。
    [[./Images/连通图.svg]]
*** 非连通图
    有两个结点之间没有直接或间接的连接。
    [[./Images/非连通图.svg]]
*** 度
**** 有向图
***** 入度
      指向该节点的边数。
***** 出度
      指向其他节点的边数。
**** 无向图
     每个节点连边的条数。
**** 图
     某点出入度之和。
**** 树
     该节点的子节点的个数。
** 快速幂
